/*
 Quake port to Silicon Labs EFR32MG24 and MGM240x
 by Nicola Wrachien (next-hack in the comments)

 Original Quake code has been deeply changed to run in only
 276 kB RAM, and 32 MB external flash, while maintaining all
 the game and 3D engine features (except music and multiplayer).

 Copyright (C) 1996-1997 Id Software, Inc.
 Copyright (C) 2023-2024 Nicola Wrachien (next-hack in the comments)
 on EFR32MG24 and MGM240 port.

 This program is free software; you can redistribute it and/or
 modify it under the terms of the GNU General Public License
 as published by the Free Software Foundation; either version 2
 of the License, or (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

 See the GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

 */
#ifndef PROGS_H
#define PROGS_H
#define	MAX_ENT_LEAFS	9  // next-hack: was 16
typedef struct
{
    short leafnums[MAX_ENT_LEAFS];
    uint8_t needs_relink;
    uint8_t num_leaves;
} entLeaves_t;
#include "pr_comp.h"			// defs shared with qcc
#include "progdefs.h"			// generated by program cdefs

typedef union eval_s
{
    string_t string;
    float _float;
    float vector[3];
    func_t function;
    int _int;
    int edict;
} eval_t;

typedef struct edict_s
{
    // NOTE: THIS MUST BE THE FIRST ONE!
    uint16_t qcc_classname :15;
    uint16_t free :1;
#if EDICTS_USE_SHORT_PTR
    int16_t nextEdict_sptr;         // sv->edicts can be before or after, so we need a signed offset. Note: we will have to allocate it before anything.
#else
    struct edict_s * nextEdict;
#endif
    link_t area;				// linked to a division node or leaf. Will be done using shortPtrs.
    full_entvars_t v;					// C exported fields from progs
// other fields from progs come immediately after
} edict_t;
#if EDICTS_USE_SHORT_PTR
#define define_edicts(name) \
typedef struct name##_edict_s\
{  \
    uint16_t qcc_classname : 15;    \
	uint16_t	free : 1;   \
    int16_t nextEdict_sptr;    \
	link_t		area;			\
	name##_entvars_t	v;				\
} name##_edict_t
#else
#define define_edicts(name) \
typedef struct name##_edict_s\
{  \
    uint16_t qcc_classname : 15;    \
	uint16_t	free : 1;   \
    struct name##_edict_s *nextEdict;    \
	link_t		area;			\
	name##_entvars_t	v;				\
} name##_edict_t

#endif
define_edicts(full);
define_edicts(missile);
define_edicts(sound);
define_edicts(bodyque);
define_edicts(light);
define_edicts(trigger);
define_edicts(info);
define_edicts(func);
define_edicts(player);
define_edicts(path_corner);
define_edicts(item);
define_edicts(worldspawn);
define_edicts(delayedUse);
define_edicts(nh_backpack);
define_edicts(nh_tfog);
define_edicts(explo_box);
define_edicts(bubble);
define_edicts(teledeath);
define_edicts(timer);
define_edicts(monster);
define_edicts(static_light);
define_edicts(nh_wiz_startfast);

//define_edicts(test);    // for testing what is going wrong
//typedef edict_t  missile_edict_t;
#define	EDICT_FROM_AREA(l) STRUCT_FROM_LINK(l,edict_t,area)

//============================================================================
#if USE_PROGSDAT
extern	dprograms_t		*progs;
extern	dfunction_t		*pr_functions;
extern	char			*pr_strings;
extern	ddef_t			*pr_globaldefs;
extern	ddef_t			*pr_fielddefs;
extern	dstatement_t	*pr_statements;
extern	globalvars_t	*pr_global_struct;
extern	float			*pr_globals;			// same as pr_global_struct

#endif

//extern	int				pr_edict_size;	// in bytes

//============================================================================

void PR_Init(void);

//void PR_ExecuteProgram (func_t fnum);
//void PR_LoadProgs (void);
void qcc_PR_ExecuteProgram(func_t fnum);

void PR_Profile_f(void);

edict_t* ED_Alloc(uint16_t className);
void ED_Free(edict_t *ed);
void ED_PendingRemoval(void);       // next-hack: added this one

char* ED_NewString(char *string);
// returns a copy of the string allocated from the server's string heap

void ED_Print(edict_t *ed);
void ED_Write(FILE *f, edict_t *ed);
char* ED_ParseEdict(char *data, edict_t *ent);

void ED_WriteGlobals(FILE *f);
void ED_ParseGlobals(char *data);

void ED_LoadFromFile(char *data);

//define EDICT_NUM(n) ((edict_t *)(sv.edicts+ (n)*pr_edict_size))
//define NUM_FOR_EDICT(e) (((byte *)(e) - sv.edicts)/pr_edict_size)

edict_t* EDICT_NUM(int n);
int NUM_FOR_EDICT(edict_t *e);
#if !EDICT_LINKED_LIST
#define	NEXT_EDICT(e) ((edict_t *)( (byte *)e + pr_edict_size))
#endif

//============================================================================
#if USE_PROGSDAT
#define	G_FLOAT(o) (pr_globals[o])
#define	G_INT(o) (*(int *)&pr_globals[o])
#define	G_VECTOR(o) (&pr_globals[o])
#define	G_STRING(o) (pr_strings + *(string_t *)&pr_globals[o])
#define	G_FUNCTION(o) (*(func_t *)&pr_globals[o])
#define	G_EDICT(o) ((edict_t *)((byte *)sv.edicts+ *(int *)&pr_globals[o]))
#define G_EDICTNUM(o) NUM_FOR_EDICT(G_EDICT(o))
#define	E_FLOAT(e,o) (((float*)&e->v)[o])
#define	E_INT(e,o) (*(int *)&((float*)&e->v)[o])
#define	E_VECTOR(e,o) (&((float*)&e->v)[o])
#define	E_STRING(e,o) (pr_strings + *(string_t *)&((float*)&e->v)[o])

#endif

extern int type_size[8];

typedef void (*builtin_t)(void);
extern builtin_t *pr_builtins;
extern int pr_numbuiltins;

extern int pr_argc;

extern qboolean pr_trace;
//extern	dfunction_t	*pr_xfunction;
extern int pr_xstatement;

extern unsigned short pr_crc;

void PR_RunError(char *error, ...);

void ED_PrintEdicts(void);
void ED_PrintNum(int ent);
#if USE_PROGSDAT
eval_t *GetEdictFieldValue(edict_t *ed, char *field);
#endif
#endif
